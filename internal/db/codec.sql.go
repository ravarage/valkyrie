// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: codec.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CreateCodec = `-- name: CreateCodec :one
INSERT INTO codec (
    name
) VALUES (
    $1
)
RETURNING id, name
`

func (q *Queries) CreateCodec(ctx context.Context, name pgtype.Text) (*Codec, error) {
	row := q.db.QueryRow(ctx, CreateCodec, name)
	var i Codec
	err := row.Scan(&i.ID, &i.Name)
	return &i, err
}

const DeleteCodec = `-- name: DeleteCodec :exec
DELETE FROM codec
WHERE id = $1
`

func (q *Queries) DeleteCodec(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, DeleteCodec, id)
	return err
}

const GetCodec = `-- name: GetCodec :one
SELECT id, name FROM codec
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetCodec(ctx context.Context, id int32) (*Codec, error) {
	row := q.db.QueryRow(ctx, GetCodec, id)
	var i Codec
	err := row.Scan(&i.ID, &i.Name)
	return &i, err
}

const GetCodecByName = `-- name: GetCodecByName :one
SELECT id, name FROM codec
WHERE name = $1 LIMIT 1
`

func (q *Queries) GetCodecByName(ctx context.Context, name pgtype.Text) (*Codec, error) {
	row := q.db.QueryRow(ctx, GetCodecByName, name)
	var i Codec
	err := row.Scan(&i.ID, &i.Name)
	return &i, err
}

const ListCodecs = `-- name: ListCodecs :many
SELECT id, name FROM codec
ORDER BY name
`

func (q *Queries) ListCodecs(ctx context.Context) ([]*Codec, error) {
	rows, err := q.db.Query(ctx, ListCodecs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Codec{}
	for rows.Next() {
		var i Codec
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateCodec = `-- name: UpdateCodec :one
UPDATE codec
SET name = $2
WHERE id = $1
RETURNING id, name
`

type UpdateCodecParams struct {
	ID   int32       `json:"id"`
	Name pgtype.Text `json:"name"`
}

func (q *Queries) UpdateCodec(ctx context.Context, arg UpdateCodecParams) (*Codec, error) {
	row := q.db.QueryRow(ctx, UpdateCodec, arg.ID, arg.Name)
	var i Codec
	err := row.Scan(&i.ID, &i.Name)
	return &i, err
}
