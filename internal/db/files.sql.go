// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: files.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CreateFile = `-- name: CreateFile :one
INSERT INTO files (
    name,
    location,
    folder_id
) VALUES (
    $1, $2, $3
)
RETURNING id, name, location, folder_id
`

type CreateFileParams struct {
	Name     pgtype.Text `json:"name"`
	Location pgtype.Text `json:"location"`
	FolderID pgtype.Int4 `json:"folder_id"`
}

func (q *Queries) CreateFile(ctx context.Context, arg CreateFileParams) (*File, error) {
	row := q.db.QueryRow(ctx, CreateFile, arg.Name, arg.Location, arg.FolderID)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Location,
		&i.FolderID,
	)
	return &i, err
}

const DeleteFile = `-- name: DeleteFile :exec
DELETE FROM files
WHERE id = $1
`

func (q *Queries) DeleteFile(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, DeleteFile, id)
	return err
}

const GetFile = `-- name: GetFile :one
SELECT id, name, location, folder_id FROM files
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetFile(ctx context.Context, id int32) (*File, error) {
	row := q.db.QueryRow(ctx, GetFile, id)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Location,
		&i.FolderID,
	)
	return &i, err
}

const GetFilePermissionsByFileId = `-- name: GetFilePermissionsByFileId :many
SELECT id, file_id, user_id, permission, granted_by, granted_at FROM file_permissions
WHERE file_id = $1
ORDER BY id
`

func (q *Queries) GetFilePermissionsByFileId(ctx context.Context, fileID pgtype.Int4) ([]*FilePermission, error) {
	rows, err := q.db.Query(ctx, GetFilePermissionsByFileId, fileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*FilePermission{}
	for rows.Next() {
		var i FilePermission
		if err := rows.Scan(
			&i.ID,
			&i.FileID,
			&i.UserID,
			&i.Permission,
			&i.GrantedBy,
			&i.GrantedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetFileVersionsByFileId = `-- name: GetFileVersionsByFileId :many
SELECT id, file_id, version, location, file_size, created_by, created_at, comment FROM file_versions
WHERE file_id = $1
ORDER BY version DESC
`

func (q *Queries) GetFileVersionsByFileId(ctx context.Context, fileID pgtype.Int4) ([]*FileVersion, error) {
	rows, err := q.db.Query(ctx, GetFileVersionsByFileId, fileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*FileVersion{}
	for rows.Next() {
		var i FileVersion
		if err := rows.Scan(
			&i.ID,
			&i.FileID,
			&i.Version,
			&i.Location,
			&i.FileSize,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.Comment,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetFileWithMetadata = `-- name: GetFileWithMetadata :one
SELECT f.id, f.name, f.location, f.folder_id, fm.file_size, fm.mime_type, fm.created_at, fm.modified_at
FROM files f
LEFT JOIN file_metadata fm ON f.id = fm.file_id
WHERE f.id = $1
LIMIT 1
`

type GetFileWithMetadataRow struct {
	ID         int32            `json:"id"`
	Name       pgtype.Text      `json:"name"`
	Location   pgtype.Text      `json:"location"`
	FolderID   pgtype.Int4      `json:"folder_id"`
	FileSize   pgtype.Int8      `json:"file_size"`
	MimeType   pgtype.Text      `json:"mime_type"`
	CreatedAt  pgtype.Timestamp `json:"created_at"`
	ModifiedAt pgtype.Timestamp `json:"modified_at"`
}

func (q *Queries) GetFileWithMetadata(ctx context.Context, id int32) (*GetFileWithMetadataRow, error) {
	row := q.db.QueryRow(ctx, GetFileWithMetadata, id)
	var i GetFileWithMetadataRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Location,
		&i.FolderID,
		&i.FileSize,
		&i.MimeType,
		&i.CreatedAt,
		&i.ModifiedAt,
	)
	return &i, err
}

const GetLatestFileVersionByFileId = `-- name: GetLatestFileVersionByFileId :one
SELECT id, file_id, version, location, file_size, created_by, created_at, comment FROM file_versions
WHERE file_id = $1
ORDER BY version DESC
LIMIT 1
`

func (q *Queries) GetLatestFileVersionByFileId(ctx context.Context, fileID pgtype.Int4) (*FileVersion, error) {
	row := q.db.QueryRow(ctx, GetLatestFileVersionByFileId, fileID)
	var i FileVersion
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.Version,
		&i.Location,
		&i.FileSize,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.Comment,
	)
	return &i, err
}

const ListFiles = `-- name: ListFiles :many
SELECT id, name, location, folder_id FROM files
ORDER BY id
`

func (q *Queries) ListFiles(ctx context.Context) ([]*File, error) {
	rows, err := q.db.Query(ctx, ListFiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Location,
			&i.FolderID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListFilesByFolder = `-- name: ListFilesByFolder :many
SELECT id, name, location, folder_id FROM files
WHERE folder_id = $1
ORDER BY id
`

func (q *Queries) ListFilesByFolder(ctx context.Context, folderID pgtype.Int4) ([]*File, error) {
	rows, err := q.db.Query(ctx, ListFilesByFolder, folderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Location,
			&i.FolderID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListFilesByTag = `-- name: ListFilesByTag :many
SELECT f.id, f.name, f.location, f.folder_id
FROM files f
JOIN file_tags ft ON f.id = ft.file_id
WHERE ft.tag_id = $1
ORDER BY f.id
`

func (q *Queries) ListFilesByTag(ctx context.Context, tagID int32) ([]*File, error) {
	rows, err := q.db.Query(ctx, ListFilesByTag, tagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Location,
			&i.FolderID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateFile = `-- name: UpdateFile :one
UPDATE files
SET name = $2,
    location = $3,
    folder_id = $4
WHERE id = $1
RETURNING id, name, location, folder_id
`

type UpdateFileParams struct {
	ID       int32       `json:"id"`
	Name     pgtype.Text `json:"name"`
	Location pgtype.Text `json:"location"`
	FolderID pgtype.Int4 `json:"folder_id"`
}

func (q *Queries) UpdateFile(ctx context.Context, arg UpdateFileParams) (*File, error) {
	row := q.db.QueryRow(ctx, UpdateFile,
		arg.ID,
		arg.Name,
		arg.Location,
		arg.FolderID,
	)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Location,
		&i.FolderID,
	)
	return &i, err
}
