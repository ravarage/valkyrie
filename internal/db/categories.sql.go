// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: categories.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CreateCategory = `-- name: CreateCategory :one
INSERT INTO categories (
    cat_key,
    name,
    description,
    t_type_id,
    category_id
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, cat_key, name, description, t_type_id, category_id
`

type CreateCategoryParams struct {
	CatKey      pgtype.Text `json:"cat_key"`
	Name        pgtype.Text `json:"name"`
	Description pgtype.Text `json:"description"`
	TTypeID     pgtype.Int4 `json:"t_type_id"`
	CategoryID  pgtype.Int4 `json:"category_id"`
}

func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) (*Category, error) {
	row := q.db.QueryRow(ctx, CreateCategory,
		arg.CatKey,
		arg.Name,
		arg.Description,
		arg.TTypeID,
		arg.CategoryID,
	)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.CatKey,
		&i.Name,
		&i.Description,
		&i.TTypeID,
		&i.CategoryID,
	)
	return &i, err
}

const DeleteCategory = `-- name: DeleteCategory :exec
DELETE FROM categories
WHERE id = $1
`

func (q *Queries) DeleteCategory(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, DeleteCategory, id)
	return err
}

const GetCategory = `-- name: GetCategory :one
SELECT id, cat_key, name, description, t_type_id, category_id FROM categories
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetCategory(ctx context.Context, id int32) (*Category, error) {
	row := q.db.QueryRow(ctx, GetCategory, id)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.CatKey,
		&i.Name,
		&i.Description,
		&i.TTypeID,
		&i.CategoryID,
	)
	return &i, err
}

const GetCategoryByKey = `-- name: GetCategoryByKey :one
SELECT id, cat_key, name, description, t_type_id, category_id FROM categories
WHERE cat_key = $1 LIMIT 1
`

func (q *Queries) GetCategoryByKey(ctx context.Context, catKey pgtype.Text) (*Category, error) {
	row := q.db.QueryRow(ctx, GetCategoryByKey, catKey)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.CatKey,
		&i.Name,
		&i.Description,
		&i.TTypeID,
		&i.CategoryID,
	)
	return &i, err
}

const ListCategories = `-- name: ListCategories :many
SELECT id, cat_key, name, description, t_type_id, category_id FROM categories
ORDER BY id
`

func (q *Queries) ListCategories(ctx context.Context) ([]*Category, error) {
	rows, err := q.db.Query(ctx, ListCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Category{}
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.CatKey,
			&i.Name,
			&i.Description,
			&i.TTypeID,
			&i.CategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListCategoriesByType = `-- name: ListCategoriesByType :many
SELECT id, cat_key, name, description, t_type_id, category_id FROM categories
WHERE t_type_id = $1
ORDER BY id
`

func (q *Queries) ListCategoriesByType(ctx context.Context, tTypeID pgtype.Int4) ([]*Category, error) {
	rows, err := q.db.Query(ctx, ListCategoriesByType, tTypeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Category{}
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.CatKey,
			&i.Name,
			&i.Description,
			&i.TTypeID,
			&i.CategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListSubcategories = `-- name: ListSubcategories :many
SELECT id, cat_key, name, description, t_type_id, category_id FROM categories
WHERE category_id = $1
ORDER BY id
`

func (q *Queries) ListSubcategories(ctx context.Context, categoryID pgtype.Int4) ([]*Category, error) {
	rows, err := q.db.Query(ctx, ListSubcategories, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Category{}
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.CatKey,
			&i.Name,
			&i.Description,
			&i.TTypeID,
			&i.CategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateCategory = `-- name: UpdateCategory :one
UPDATE categories
SET cat_key = $2,
    name = $3,
    description = $4,
    t_type_id = $5,
    category_id = $6
WHERE id = $1
RETURNING id, cat_key, name, description, t_type_id, category_id
`

type UpdateCategoryParams struct {
	ID          int32       `json:"id"`
	CatKey      pgtype.Text `json:"cat_key"`
	Name        pgtype.Text `json:"name"`
	Description pgtype.Text `json:"description"`
	TTypeID     pgtype.Int4 `json:"t_type_id"`
	CategoryID  pgtype.Int4 `json:"category_id"`
}

func (q *Queries) UpdateCategory(ctx context.Context, arg UpdateCategoryParams) (*Category, error) {
	row := q.db.QueryRow(ctx, UpdateCategory,
		arg.ID,
		arg.CatKey,
		arg.Name,
		arg.Description,
		arg.TTypeID,
		arg.CategoryID,
	)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.CatKey,
		&i.Name,
		&i.Description,
		&i.TTypeID,
		&i.CategoryID,
	)
	return &i, err
}
